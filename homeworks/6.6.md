1.
    - напишите список операций, которые вы будете производить для остановки запроса пользователя

        # Находим opid зависшей операции 
        db.currentOp(
           {
             "active" : true,
             "secs_running" : { "$gt" : 180 }
           }
        )
        # Прерываем операцию
        db.killOp(opid)
    
    - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
    
    Не было опыта работы с MongoDB, но судя по всему, как и в других СУБД, тут можно настроить лог медленных запросов. Потом смотреть, какие запросы попадают в этот лог, делать их explain и анализировать возможные причины, оптимизировать запросы, индексы и т.п.
    
2. Не уверен в своем "решении", что-то не гуглится этот вопрос.  
      
    Если исходить из документации https://redis.io/topics/latency , то там по смыслу подходит только блок "Latency generated by expires", и вывод там такой: "In short: be aware that many keys expiring at the same moment can be a source of latency.". Но насколько большой может быть эта задержка, не могу сказать. Можно предположить, что в ходе репликации была приостановка работы, и потом после возвобновления работы сразу много ключей истекло.

3. Исходя из документации https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html нам подходит такая причина:  
      
    Sometimes the "during query" form happens when millions of rows are being sent as part of one or more queries. If you know that this is happening, you should try increasing net_read_timeout from its default of 30 seconds to 60 seconds or longer, sufficient for the data transfer to complete.  
      
    То есть, можно увеличить значение паременной (настройки) net_read_timeout.  
    Но скорее всего, нам не нужно, чтобы слишком много строк извлекалось. Возможно, надо оптимизировать запросы и код программы, чтобы делать более точные выборки.

4. Если исходить из того, как победить проблему "Out of Memory", то есть хорошая статья https://habr.com/ru/company/southbridge/blog/464245/ , а также официальная документация https://www.postgresql.org/docs/current/kernel-resources.html . Я бы попробовал выполнить все, что сказано тут https://www.postgresql.org/docs/current/kernel-resources.html в блоке "19.4.4. Linux Memory Overcommit", если процитировать команды, то вот это:

        sysctl -w vm.overcommit_memory=2

        # Это пишется в стартовом скрипте postmaster:

        echo -1000 > /proc/self/oom_score_adj

        export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
        export PG_OOM_ADJUST_VALUE=0
        
