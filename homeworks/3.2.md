1. Это встроенная команда оболочки (shell builtin). Если бы cd была внешней программой, то она бы меняла рабочую директорию внутри своего процесса, а не родительского. Поэтому данная команда должна быть реализована внутри самой командной оболочки (чтобы действие происходило в своем собственном процессе).

2.
        grep -c <some_string> <some_file>

3. systemd

4. 
        ls --test 2>/dev/pts/1

5. Затрудняюсь сразу найти какую-то утилиту, использующую и ввод и вывод. Чисто для примера можно взять at (планирование задачи), только она выводит сообщения в stderr, но их мы можем перенаправить в stdout, чтобы соответствовать постановке задачи. Тогда будет такая команда:

        at 23:02 < test_commands.txt > at_output.txt 2>&1

    В test_commands.txt какие-то команды записаны, например:

        echo $PATH

    В at_output.txt записывается вывод:

        warning: commands will be executed using /bin/sh
        job 9 at Sun Jun 27 23:02:00 2021

6. Сделал так:
   - В Vagrantfile включил GUI:
     
           config.vm.provider "virtualbox" do |vb|
             vb.gui = true
           end
   - Запустил Ubuntu через `vagrant up`, в итоге запустилось графическое окошко, где было написано, что это tty1, залогинился в этом терминале под юзером vagrant
   - В обычном терминале тоже залогинился через команду `vagrant ssh`
   - В этом обычном терминале делаю команду:
   
         echo Hello world >/dev/tty1
   
   - И вижу текст "Hello world" в GUI-терминале.
   

7. Видимо, `bash 5>&1` делает fd 5 потоком вывода (перенаправляет в стандартный вывод). Поэтому `echo netology > /proc/$$/fd/5` просто выводит слово netology в стандартный вывод (в терминал).

8. 

        # Перенаправляем fd 5 в стандартный поток вывода
        vagrant@vagrant:~/homeworks/3.2$ exec 5>&1
        # Пример команды с выводом stderr
        vagrant@vagrant:~/homeworks/3.2$ ls --txt
        ls: unrecognized option '--txt'
        Try 'ls --help' for more information.
        # Пример команды с выводом stdout
        vagrant@vagrant:~/homeworks/3.2$ ls -l
        total 12
        -rw-rw-r-- 1 vagrant vagrant  0 Jun 28 07:12 1
        -rw-rw-r-- 1 vagrant vagrant 79 Jun 28 07:04 at_output.txt
        -rw-rw-r-- 1 vagrant vagrant 12 Jun 27 11:47 test_commands.txt
        -rw-rw-r-- 1 vagrant vagrant 19 Jun 27 11:13 test.txt
        # Решение. stdout идет в терминал и не идет через pipe. При этом в pipe идет stderr (выводится, что в stderr 0 совпадений искомой строки)
        vagrant@vagrant:~/homeworks/3.2$ ls -l 2>&1 >&5 | grep -c txt
        total 12
        -rw-rw-r-- 1 vagrant vagrant  0 Jun 28 07:12 1
        -rw-rw-r-- 1 vagrant vagrant 79 Jun 28 07:04 at_output.txt
        -rw-rw-r-- 1 vagrant vagrant 12 Jun 27 11:47 test_commands.txt
        -rw-rw-r-- 1 vagrant vagrant 19 Jun 27 11:13 test.txt
        0
        # Решение. Пример с ошибкой, stderr идет через pipe, где grep находит 1 совпадение
        vagrant@vagrant:~/homeworks/3.2$ ls --txt 2>&1 >&5 | grep -c txt
        1

9. `cat /proc/$$/environ` выводит содержимое файла, в котором содержатся переменные окружения на момент старта процесса командной оболочки. Вывод команды неудобный, т.к. переменные разделены нулевым байтом (визуально не отображается), и все сливается в 1 строку. Лучше было бы использовать `strings /proc/$$/environ`, тогда мы получили бы тот же вывод, что и команда `env`, за небольшим исключением, т.к. `env` уже может содержать текущие изменения переменных среды окружения (например, у меня она содержит новую переменную OLDPWD).


10. По адресу `/proc/<PID>/cmdline` содержится полная команда текущего процесса (которой он был запущен), со всем аргументами и т.п. (если этот процесс не зомби); но аргументы там разделены нулевым байтом, а не пробелами. `/proc/<PID>/exe` - это символическая ссылка, содержащая путь к исполняемой (запущенной) команде. Эти файлы можно посмотреть так:
    
         vagrant@vagrant:~/homeworks/3.2$ ls -l /proc/$$/exe
         lrwxrwxrwx 1 vagrant vagrant 0 Jun 28 09:07 /proc/1220/exe -> /usr/bin/bash
         
         vagrant@vagrant:~/homeworks/3.2$ strings /proc/$$/cmdline
         bash

11. В `/proc/cpuinfo` есть флаги от sse до sse4_2, т.е. поддерживает все эти версии инструкций SSE.

12. Прочитал, что при выполнении команд на удаленной машине (при указании этих команд в последнем параметре команды ssh), псевдо-терминал не выделяется. Но можно использовать опцию -t (Force pseudo-terminal allocation), чтобы принудительно выделить псевдо-терминал:

         vagrant@vagrant:~/homeworks/3.2$ ssh -t localhost 'tty'
         vagrant@localhost's password:
         /dev/pts/2
         Connection to localhost closed.

    Получаем вывод удаленной команды tty, после чего сессия ssh закрывается (т.к. все переданные команды выполнены).


13. Сначала установил программу
    
         sudo apt-get install reptyr

    Потом reptyr не заработал должным образом и выдал ошибку что-то про права, и пришлось в файле `/etc/sysctl.d/10-ptrace.conf` поставить настройку `kernel.yama.ptrace_scope = 0` и перезагрузить настройки из конфига:

         sudo sysctl --system

    Потом запускаю для примера команду `top`:

        vagrant@vagrant:~$ top
    
    Нажимаю `Ctrl + Z`

        vagrant@vagrant:~$ bg
        [1]+ top &
        vagrant@vagrant:~$ ps -a
            PID TTY          TIME CMD
           1722 pts/0    00:00:00 top
           1723 pts/0    00:00:00 ps
        vagrant@vagrant:~$ screen
    
    Уже в новой вкладке:

        vagrant@vagrant:~$ reptyr 1722

    Видим, что `top` работает (обновляет данные). Потом выходим из вкладки `Ctrl + A`, затем `D`.
    <br><br>
    Потом в осн. терминале `exit`, затем снова входим через `vagrant ssh`, потом `screen -r` и видим, что `top` до сих пор работает.
    <br><br>
    Единственная проблема в этом примере, что во 2-м терминале (вкладке screen), если нажать `Ctrl + Z`, то работа программы останавливается (данные не обновляются), но управление не переходит к командной строке этой вкладки (т.е. идет ввод просто на экране, но никакие команды запустить нельзя...). Возможно, это связано с тем, что сам процесс `top` все равно числится относящимся к исходному терминалу (TTY = pts/0), это если смотреть через `ls -a`. Можно это как-то победить, чтобы `Ctrl + Z` корректно работал?


14. Команда `tee` читает из стандартного ввода и пишет данные в файл(ы) и стандартный вывод. Т.к. это отдельная утилита, и мы ее запускаем через sudo, то она может записать в файл в папке `/root`.
